# data-structures-and-algorithms

# Challenge 6
<!-- Description of the challenge -->
## linked-list-insertions
1.create linkedlist 
2.create three method:
** append >> that adds a new node with the given value to the end of the list.
**insert before>> adds a new node with the given new value immediately before the first node that has the value specified
**insert after>>adds a new node with the given new value immediately after the first node that has the value specified
3.wrote test cases :
test Append Singl eNode
test Append Multiple Nodes
test Insert Before Middle
test Insert Before First
test Insert After Middle
test Insert After Last




## Whiteboard Process
<!-- Embedded whiteboard image -->

![whiteboard6.png](pic%2Fwhiteboard6.png)

## Approach & Efficiency
<!-- What approach did you take? Why? What is the Big O space/time for this approach? -->
1. The first thing specify the problem (search binary)
2. Draw simple diagram to understand the idea of search key
3. Try to write the code for this part
4. Write the whole code using java language
5. Run the code to be sure is it correct
6. write the test cases 
6. Drawing the data structure in whiteboard

## it took three hours  and test cases then draw the whiteboard.


## Time Complexity (O( n))
## Space Complexity (O(n))

## Solution
<!-- Show how to run your code, and examples of it in action -->
this the output in the terminal :
![runcc6.PNG](pic%2Fruncc6.PNG)
![testcc6.PNG](pic%2Ftestcc6.PNG)
![gradletest6.PNG](pic%2Fgradletest6.PNG)