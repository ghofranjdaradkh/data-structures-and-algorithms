# data-structures-and-algorithms

# Challenge 10
<!-- Description of the challenge -->
## Write code to implementation Stack and Queue classes 
# Stack
Implement a Stack class that models a stack data structure with a top property.
The class should provide the following methods:
**push(value: T)**: Adds the given value to the top of the stack.
**pop()**: Removes and returns the value from the top of the stack.
**peek(**): Returns the value from the top of the stack without removing it.
**isEmpty()**: Returns a Boolean indicating whether the stack is empty or not.
# Queue
Implement a Queue class that models a stack data structure with a front and back properties.
The class should provide the following methods:
**enqueue** adds an element to the back (end) of the queue.
**peek** returns the element at the front (start) of the queue without removing it.
**dequeue** removes and returns the element at the front (start) of the queue.
**isEmpty** checks whether the queue is empty or not.



## Whiteboard Process
<!-- Embedded whiteboard image -->
# Stack
![image (34).png](pic%2Fimage%20%2834%29.png)

# Queue
![image (33).png](pic%2Fimage%20%2833%29.png)


## Approach & Efficiency
<!-- What approach did you take? Why? What is the Big O space/time for this approach? -->
1. The first thing specify the problem (implementation stack and queue classes and Node)
2. Draw simple diagram to understand the idea
3. Try to write the code for this part
4. Write the whole code using java language
5. Run the code to be sure is it correct
6. write test cases for code and then run it
7. Drawing the data structure in white board 

it takes 4 hours to deal with Stack and Queue and draw the white board.


## Time Complexity (O(1)
## Space Complexity (O(1))


## Solution
<!-- Show how to run your code,and examples of it in action -->
output :
![outputRunDS.PNG](pic%2FoutputRunDS.PNG)
 test cases:
![outputDS.PNG](pic%2FoutputDS.PNG)

gradlew test:
![gradlewDS.PNG](pic%2FgradlewDS.PNG)

